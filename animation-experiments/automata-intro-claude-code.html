<!--
RECONSTRUCTED PROMPT:
Create a three.js intro animation for "Automata Learning Lab" that serves as an opening sequence. The animation should include:
- A neural network visualization with nodes and connections
- Floating particles in the background for atmosphere
- A central automaton structure with core and shell (wireframe icosahedrons)
- Animated text that fades in: "AUTOMATA LEARNING LAB" and "AI Tools & Technology"
- Futuristic typography using the 'Gagalin' font
- Cyan and magenta color scheme for a high-tech feel
- Pulsing animations on nodes with varying intensities
- Rotating camera movement for dynamic perspective
- Loading text indicating "Initializing Systems..."
- Fade-out after 6 seconds to transition to main content
- Professional presentation suitable for a YouTube channel intro
The overall aesthetic should be cutting-edge, scientific, and convey expertise in AI and automata theory.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automata Learning Lab - Intro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <style>
        @import url('https://fonts.cdnfonts.com/css/gagalin');
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Gagalin', sans-serif;
            background: #000;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #title-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
        
        .title {
            font-family: 'Gagalin', sans-serif;
            font-size: 4rem;
            font-weight: normal;
            color: #fff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            opacity: 0;
            animation: fadeInTitle 2s ease-in-out forwards;
            animation-delay: 1.5s;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        
        .subtitle {
            font-family: 'Gagalin', sans-serif;
            font-size: 1.5rem;
            color: #00ffff;
            margin-top: 20px;
            opacity: 0;
            animation: fadeInTitle 2s ease-in-out forwards;
            animation-delay: 2.5s;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
        }
        
        @keyframes fadeInTitle {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .loading-text {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #00ffff;
            font-size: 0.9rem;
            opacity: 0;
            animation: pulse 2s infinite;
            animation-delay: 3.5s;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="title-container">
            <h1 class="title">AUTOMATA LEARNING LAB</h1>
            <p class="subtitle">AI Tools & Technology</p>
        </div>
        <div class="loading-text">Initializing Systems...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x00ffff, 2);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00ff, 2);
        pointLight2.position.set(-5, -5, 5);
        scene.add(pointLight2);

        // Create neural network nodes
        const nodes = [];
        const connections = [];
        const nodeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
        const nodeMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 0.5
        });

        // Create a grid of nodes
        for (let i = 0; i < 5; i++) {
            for (let j = 0; j < 5; j++) {
                for (let k = 0; k < 3; k++) {
                    const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
                    node.position.set(
                        (i - 2) * 2,
                        (j - 2) * 2,
                        (k - 1) * 3
                    );
                    nodes.push(node);
                    scene.add(node);
                }
            }
        }

        // Create connections between nodes
        const connectionMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ffff,
            opacity: 0.3,
            transparent: true
        });

        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                if (Math.random() > 0.85) {
                    const points = [];
                    points.push(nodes[i].position);
                    points.push(nodes[j].position);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, connectionMaterial);
                    connections.push(line);
                    scene.add(line);
                }
            }
        }

        // Create floating particles
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 1000;
        const posArray = new Float32Array(particlesCount * 3);

        for (let i = 0; i < particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 50;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.005,
            color: 0x00ffff,
            transparent: true,
            opacity: 0.8
        });

        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        // Central automaton shape
        const automaton = new THREE.Group();
        
        // Core
        const coreGeometry = new THREE.IcosahedronGeometry(1, 1);
        const coreMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 0.2,
            wireframe: true
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        automaton.add(core);

        // Outer shell
        const shellGeometry = new THREE.IcosahedronGeometry(1.5, 1);
        const shellMaterial = new THREE.MeshPhongMaterial({
            color: 0xff00ff,
            emissive: 0xff00ff,
            emissiveIntensity: 0.1,
            wireframe: true,
            opacity: 0.5,
            transparent: true
        });
        const shell = new THREE.Mesh(shellGeometry, shellMaterial);
        automaton.add(shell);

        scene.add(automaton);

        // Camera positioning
        camera.position.z = 15;

        // Animation variables
        let time = 0;

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Rotate automaton
            automaton.rotation.x = time * 0.5;
            automaton.rotation.y = time * 0.3;
            
            // Pulse effect
            const scale = 1 + Math.sin(time * 2) * 0.1;
            automaton.scale.set(scale, scale, scale);

            // Animate nodes
            nodes.forEach((node, index) => {
                const offset = index * 0.1;
                node.material.emissiveIntensity = 0.5 + Math.sin(time * 2 + offset) * 0.5;
                node.position.y += Math.sin(time + offset) * 0.01;
            });

            // Animate particles
            particlesMesh.rotation.y = time * 0.1;
            particlesMesh.rotation.x = time * 0.05;

            // Camera movement
            camera.position.x = Math.sin(time * 0.5) * 5;
            camera.position.y = Math.cos(time * 0.5) * 2;
            camera.lookAt(0, 0, 0);

            // Animate connections
            connections.forEach((connection, index) => {
                connection.material.opacity = 0.3 + Math.sin(time * 3 + index) * 0.2;
            });

            renderer.render(scene, camera);
        }

        animate();

        // Optional: Auto-fade out after 6 seconds
        setTimeout(() => {
            document.body.style.transition = 'opacity 1s';
            document.body.style.opacity = '0';
        }, 6000);
    </script>
</body>
</html>