<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini API Image Bounding Box Visualization</title>
    <script type="module">
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";
        import { marked } from "https://esm.run/marked";

        function getApiKey() {
            let apiKey = localStorage.getItem("GEMINI_API_KEY");
            if (!apiKey) {
                apiKey = prompt("Please enter your Gemini API key:");
                if (apiKey) {
                    localStorage.setItem("GEMINI_API_KEY", apiKey);
                }
            }
            return apiKey;
        }

        async function getGenerativeModel(params) {
            const API_KEY = getApiKey();
            const genAI = new GoogleGenerativeAI(API_KEY);
            return genAI.getGenerativeModel(params);
        }

        async function fileToGenerativePart(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve({
                    inlineData: { 
                        data: reader.result.split(",")[1],
                        mimeType: file.type 
                    }
                });
                reader.readAsDataURL(file);
            });
        }

        function resizeAndCompressImage(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        let width = img.width;
                        let height = img.height;

                        if (width > 1000) {
                            height = Math.round((height * 1000) / width);
                            width = 1000;
                        }

                        canvas.width = width;
                        canvas.height = height;

                        ctx.drawImage(img, 0, 0, width, height);

                        canvas.toBlob((blob) => {
                            resolve(new File([blob], "compressed_image.jpg", { type: "image/jpeg" }));
                        }, 'image/jpeg', 0.7);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        async function processImageAndPrompt() {
            const fileInput = document.getElementById('imageInput');
            const promptInput = document.getElementById('promptInput');
            const resultDiv = document.getElementById('result');
            const modelSelect = document.getElementById('modelSelect');
            
            if (!promptInput.value) {
                alert('Please enter a prompt.');
                return;
            }

            resultDiv.innerHTML = 'Processing...';
            
            // Clear previous bounding box images
            document.getElementById('boundingBoxImages').innerHTML = '';
            
            try {
                const model = await getGenerativeModel({ model: modelSelect.value });
                let content = [promptInput.value];

                if (fileInput.files[0]) {
                    const compressedImage = await resizeAndCompressImage(fileInput.files[0]);
                    const imagePart = await fileToGenerativePart(compressedImage);
                    content.push(imagePart);
                }
                
                const result = await model.generateContent(content);
                const response = await result.response;
                const text = response.text();
                
                resultDiv.innerHTML = marked.parse(text);

                if (fileInput.files[0]) {
                    // Extract coordinates from the response
                    const coordinates = extractCoordinates(text);
                    if (coordinates.length > 0) {
                        displayImageWithBoundingBoxes(fileInput.files[0], coordinates);
                    }
                }
            } catch (error) {
                resultDiv.innerHTML = `Error: ${error.message}`;
            }
        }

        function extractCoordinates(text) {
            const regex = /\[\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\]/g;
            const matches = text.match(regex) || [];
            return matches.map(JSON.parse);
        }

        function displayImageWithBoundingBoxes(file, coordinates) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const image = new Image();
                image.onload = function() {
                    const canvas = document.getElementById('canvas');
                    canvas.width = image.width + 100;
                    canvas.height = image.height + 100;
                    const ctx = canvas.getContext('2d');
                    
                    let activeBox = null;
                    let isDragging = false;
                    let isResizing = false;
                    let dragStartX = 0;
                    let dragStartY = 0;
                    let resizeHandle = '';

                    // Convert coordinate arrays to box objects
                    let boxes = coordinates.map((box, index) => {
                        const [ymin, xmin, ymax, xmax] = box.map(coord => coord / 1000);
                        return {
                            x: xmin * image.width + 80,
                            y: ymin * image.height + 20,
                            width: (xmax - xmin) * image.width,
                            height: (ymax - ymin) * image.height,
                            color: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'][index % 6]
                        };
                    });

                    function draw() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw the image
                        ctx.drawImage(image, 80, 20);

                        // Draw grid lines and axes (your existing grid drawing code here)
                        // ...

                        // Draw boxes
                        boxes.forEach(box => {
                            ctx.strokeStyle = box.color;
                            ctx.lineWidth = 5;
                            ctx.strokeRect(box.x, box.y, box.width, box.height);

                            // Draw resize handles if box is active
                            if (box === activeBox) {
                                drawResizeHandles(box);
                            }
                        });
                    }

                    function drawResizeHandles(box) {
                        const handleSize = 8;
                        const handles = [
                            { x: box.x - handleSize/2, y: box.y - handleSize/2, cursor: 'nw-resize', name: 'nw' },
                            { x: box.x + box.width - handleSize/2, y: box.y - handleSize/2, cursor: 'ne-resize', name: 'ne' },
                            { x: box.x - handleSize/2, y: box.y + box.height - handleSize/2, cursor: 'sw-resize', name: 'sw' },
                            { x: box.x + box.width - handleSize/2, y: box.y + box.height - handleSize/2, cursor: 'se-resize', name: 'se' }
                        ];

                        handles.forEach(handle => {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(handle.x, handle.y, handleSize, handleSize);
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(handle.x, handle.y, handleSize, handleSize);
                        });
                    }

                    function getMousePos(evt) {
                        const rect = canvas.getBoundingClientRect();
                        return {
                            x: evt.clientX - rect.left,
                            y: evt.clientY - rect.top
                        };
                    }

                    function isInHandle(pos, box) {
                        const handleSize = 8;
                        const handles = [
                            { x: box.x - handleSize/2, y: box.y - handleSize/2, name: 'nw' },
                            { x: box.x + box.width - handleSize/2, y: box.y - handleSize/2, name: 'ne' },
                            { x: box.x - handleSize/2, y: box.y + box.height - handleSize/2, name: 'sw' },
                            { x: box.x + box.width - handleSize/2, y: box.y + box.height - handleSize/2, name: 'se' }
                        ];

                        for (let handle of handles) {
                            if (pos.x >= handle.x && pos.x <= handle.x + handleSize &&
                                pos.y >= handle.y && pos.y <= handle.y + handleSize) {
                                return handle.name;
                            }
                        }
                        return '';
                    }

                    function isInBox(pos, box) {
                        return pos.x >= box.x && pos.x <= box.x + box.width &&
                               pos.y >= box.y && pos.y <= box.y + box.height;
                    }

                    canvas.addEventListener('mousedown', (e) => {
                        const pos = getMousePos(e);
                        
                        boxes.forEach(box => {
                            const handle = isInHandle(pos, box);
                            if (handle) {
                                activeBox = box;
                                isResizing = true;
                                resizeHandle = handle;
                                return;
                            }
                            if (isInBox(pos, box)) {
                                activeBox = box;
                                isDragging = true;
                                dragStartX = pos.x - box.x;
                                dragStartY = pos.y - box.y;
                                return;
                            }
                        });
                        draw();
                    });

                    canvas.addEventListener('mousemove', (e) => {
                        const pos = getMousePos(e);

                        if (isDragging && activeBox) {
                            activeBox.x = pos.x - dragStartX;
                            activeBox.y = pos.y - dragStartY;
                            draw();
                        } else if (isResizing && activeBox) {
                            switch(resizeHandle) {
                                case 'se':
                                    activeBox.width = pos.x - activeBox.x;
                                    activeBox.height = pos.y - activeBox.y;
                                    break;
                                case 'sw':
                                    const newWidth = activeBox.x + activeBox.width - pos.x;
                                    activeBox.x = pos.x;
                                    activeBox.width = newWidth;
                                    activeBox.height = pos.y - activeBox.y;
                                    break;
                                case 'ne':
                                    activeBox.width = pos.x - activeBox.x;
                                    const newHeight = activeBox.y + activeBox.height - pos.y;
                                    activeBox.y = pos.y;
                                    activeBox.height = newHeight;
                                    break;
                                case 'nw':
                                    const newW = activeBox.x + activeBox.width - pos.x;
                                    const newH = activeBox.y + activeBox.height - pos.y;
                                    activeBox.x = pos.x;
                                    activeBox.y = pos.y;
                                    activeBox.width = newW;
                                    activeBox.height = newH;
                                    break;
                            }
                            draw();
                        }
                    });

                    canvas.addEventListener('mouseup', () => {
                        isDragging = false;
                        isResizing = false;
                        activeBox = null;
                        draw();
                    });

                    canvas.addEventListener('mouseleave', () => {
                        isDragging = false;
                        isResizing = false;
                        activeBox = null;
                        draw();
                    });

                    // Initial draw
                    draw();
                };
                image.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function clearImage() {
            document.getElementById('imageInput').value = '';
            document.getElementById('canvas').getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('imagePreview').src = '';
            document.getElementById('imagePreview').style.display = 'none';
            document.getElementById('boundingBoxImages').innerHTML = '';
        }

        function previewImage(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = document.getElementById('imagePreview');
                    img.src = e.target.result;
                    img.style.display = 'block';
                }
                reader.readAsDataURL(file);
            }
        }

        // Attach event listeners
        document.getElementById('submitBtn').addEventListener('click', processImageAndPrompt);
        document.getElementById('clearImageBtn').addEventListener('click', clearImage);
        document.getElementById('imageInput').addEventListener('change', previewImage);
        
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        textarea {
            width: 100%;
            height: 100px;
        }
        #result, #imageContainer {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 10px;
        }
        #canvas {
            max-width: 100%;
            height: auto;
        }
        #imagePreview {
            max-width: 100%;
            display: none;
            margin-top: 10px;
        }
        #boundingBoxImages {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .bounding-box-container {
            display: block;
            margin-bottom: 20px;
        }
        .bounding-box-container p {
            margin: 0 0 5px 0;
            font-weight: bold;
        }
        .bounding-box-container img {
            display: block;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <h1>Gemini API Image Bounding Box Visualization</h1>
    <select id="modelSelect">
        <option value="gemini-2.0-flash-exp">gemini-2.0-flash-exp</option>
        <option value="gemini-1.5-pro-latest">gemini-1.5-pro</option>
        <option value="gemini-1.5-flash-latest">gemini-1.5-flash</option>
        <option value="gemini-1.5-flash-8b-latest">gemini-1.5-flash-8b</option>
    </select>
    <input type="file" id="imageInput" accept="image/*">
    <button id="clearImageBtn">Clear Image</button>
    <textarea id="promptInput">Return bounding boxes as JSON arrays [ymin, xmin, ymax, xmax]
</textarea>
    <button id="submitBtn">Process</button>
    <div id="result"></div>
    <div id="imageContainer">
        <img id="imagePreview" alt="Image preview" />
        <canvas id="canvas"></canvas>
    </div>
    <div id="boundingBoxImages"></div>
</body>
</html>