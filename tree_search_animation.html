
    <script>
        class TreeNode {
            constructor(value, x, y) {
                this.value = value;
                this.x = x;
                this.y = y;
                this.children = [];
                this.parent = null;
                this.element = null;
                this.visited = false;
            }
        }

        class TreeSearchVisualizer {
            constructor() {
                this.root = null;
                this.targetValue = null;
                this.nodes = [];
                this.edges = [];
                this.currentNode = null;
                this.visitedCount = 0;
                this.stepCount = 0;
                this.isSearching = false;
                this.searchQueue = [];
                this.searchStack = [];
                this.path = [];
                
                this.container = document.getElementById('treeContainer');
                this.algorithm = document.getElementById('algorithm');
                this.startBtn = document.getElementById('startBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.generateBtn = document.getElementById('generateBtn');
                
                this.initializeEventListeners();
                this.generateTree();
            }

            initializeEventListeners() {
                this.startBtn.addEventListener('click', () => this.startSearch());
                this.resetBtn.addEventListener('click', () => this.reset());
                this.generateBtn.addEventListener('click', () => this.generateTree());
            }

            generateTree() {
                this.reset();
                this.nodes = [];
                this.edges = [];
                this.container.innerHTML = '';

                // Create a balanced binary tree
                const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
                this.targetValue = values[Math.floor(Math.random() * values.length)];
                
                this.root = new TreeNode(values[0], 400, 50);
                this.nodes.push(this.root);

                // Build tree structure
                for (let i = 0; i < 7; i++) {
                    const node = this.nodes[i];
                    const leftIndex = 2 * i + 1;
                    const rightIndex = 2 * i + 2;

                    if (leftIndex < values.length) {
                        const leftChild = new TreeNode(
                            values[leftIndex],
                            node.x - (200 / Math.pow(2, Math.floor(i / 2))),
                            node.y + 80
                        );
                        leftChild.parent = node;
                        node.children.push(leftChild);
                        this.nodes.push(leftChild);
                    }

                    if (rightIndex < values.length) {
                        const rightChild = new TreeNode(
                            values[rightIndex],
                            node.x + (200 / Math.pow(2, Math.floor(i / 2))),
                            node.y + 80
                        );
                        rightChild.parent = node;
                        node.children.push(rightChild);
                        this.nodes.push(rightChild);
                    }
                }

                this.renderTree();
                this.updateStats();
                
                // Highlight target
                const targetNode = this.nodes.find(n => n.value === this.targetValue);
                if (targetNode) {
                    targetNode.element.classList.add('target');
                }

                document.getElementById('pathList').innerHTML = `Target: ${this.targetValue}`;
            }

            renderTree() {
                // Render edges first
                this.nodes.forEach(node => {
                    node.children.forEach(child => {
                        this.createEdge(node, child);
                    });
                });

                // Render nodes
                this.nodes.forEach(node => {
                    this.createNode(node);
                });
            }

            createNode(node) {
                const element = document.createElement('div');
                element.className = 'node';
                element.textContent = node.value;
                element.style.left = (node.x - 20) + 'px';
                element.style.top = node.y + 'px';
                
                element.addEventListener('click', () => {
                    if (!this.isSearching) {
                        this.targetValue = node.value;
                        this.reset();
                        this.nodes.forEach(n => n.element.classList.remove('target'));
                        element.classList.add('target');
                        document.getElementById('pathList').innerHTML = `Target: ${this.targetValue}`;
                    }
                });

                node.element = element;
                this.container.appendChild(element);
            }

            createEdge(from, to) {
                const edge = document.createElement('div');
                edge.className = 'edge';
                
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                edge.style.width = length + 'px';
                edge.style.height = '3px';
                edge.style.left = from.x + 'px';
                edge.style.top = (from.y + 20) + 'px';
                edge.style.transform = `rotate(${angle}deg)`;
                
                this.edges.push(edge);
                this.container.appendChild(edge);
            }

            async startSearch() {
                if (this.isSearching) return;
                
                this.isSearching = true;
                this.startBtn.disabled = true;
                this.visitedCount = 0;
                this.stepCount = 0;
                this.path = [];
                
                const algorithmType = this.algorithm.value;
                
                if (algorithmType === 'dfs') {
                    await this.depthFirstSearch();
                } else if (algorithmType === 'bfs') {
                    await this.breadthFirstSearch();
                } else {
                    await this.randomSearch();
                }
                
                this.isSearching = false;
                this.startBtn.disabled = false;
            }

            async depthFirstSearch() {
                this.searchStack = [this.root];
                document.getElementById('status').textContent = 'DFS Running...';
                
                while (this.searchStack.length > 0) {
                    const current = this.searchStack.pop();
                    await this.visitNode(current);
                    
                    if (current.value === this.targetValue) {
                        document.getElementById('status').textContent = 'Target Found!';
                        return;
                    }
                    
                    // Add children to stack (right to left for left-first traversal)
                    for (let i = current.children.length - 1; i >= 0; i--) {
                        if (!current.children[i].visited) {
                            this.searchStack.push(current.children[i]);
                        }
                    }
                    
                    await this.delay(800);
                }
                
                document.getElementById('status').textContent = 'Target Not Found';
            }

            async breadthFirstSearch() {
                this.searchQueue = [this.root];
                document.getElementById('status').textContent = 'BFS Running...';
                
                while (this.searchQueue.length > 0) {
                    const current = this.searchQueue.shift();
                    await this.visitNode(current);
                    
                    if (current.value === this.targetValue) {
                        document.getElementById('status').textContent = 'Target Found!';
                        return;
                    }
                    
                    // Add children to queue
                    current.children.forEach(child => {
                        if (!child.visited) {
                            this.searchQueue.push(child);
                        }
                    });
                    
                    await this.delay(800);
                }
                
                document.getElementById('status').textContent = 'Target Not Found';
            }

            async randomSearch() {
                document.getElementById('status').textContent = 'Random Search Running...';
                let unvisited = [...this.nodes];
                
                while (unvisited.length > 0) {
                    const randomIndex = Math.floor(Math.random() * unvisited.length);
                    const current = unvisited[randomIndex];
                    unvisited.splice(randomIndex, 1);
                    
                    await this.visitNode(current);
                    
                    if (current.value === this.targetValue) {
                        document.getElementById('status').textContent = 'Target Found!';
                        return;
                    }
                    
                    await this.delay(600);
                }
                
                document.getElementById('status').textContent = 'Target Not Found';
            }

            async visitNode(node) {
                if (this.currentNode) {
                    this.currentNode.element.classList.remove('current');
                    this.currentNode.element.classList.add('visited');
                }
                
                node.visited = true;
                node.element.classList.add('current');
                this.currentNode = node;
                this.visitedCount++;
                this.stepCount++;
                this.path.push(node.value);
                
                // Highlight edge to parent
                if (node.parent) {
                    const edgeIndex = this.getEdgeIndex(node.parent, node);
                    if (edgeIndex !== -1) {
                        this.edges[edgeIndex].classList.add('active');
                    }
                }
                
                this.updateStats();
                this.updatePath();
            }

            getEdgeIndex(from, to) {
                // Simple way to find edge - in real implementation, you'd store edge references
                return this.edges.findIndex(edge => {
                    const rect = edge.getBoundingClientRect();
                    const fromRect = from.element.getBoundingClientRect();
                    return Math.abs(rect.left - fromRect.left) < 5;
                });
            }

            updateStats() {
                document.getElementById('visitedCount').textContent = this.visitedCount;
                document.getElementById('stepCount').textContent = this.stepCount;
            }

            updatePath() {
                const pathElement = document.getElementById('pathList');
                pathElement.innerHTML = `Target: ${this.targetValue}<br>Path: ${this.path.join(' â†’ ')}`;
            }

            reset() {
                this.nodes.forEach(node => {
                    if (node.element) {
                        node.element.classList.remove('visited', 'current');
                        node.visited = false;
                    }
                });
                
                this.edges.forEach(edge => {
                    edge.classList.remove('active');
                });
                
                this.currentNode = null;
                this.visitedCount = 0;
                this.stepCount = 0;
                this.path = [];
                this.isSearching = false;
                this.startBtn.disabled = false;
                
                document.getElementById('status').textContent = 'Ready';
                this.updateStats();
                document.getElementById('pathList').innerHTML = `Target: ${this.targetValue || 'Click a node'}`;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TreeSearchVisualizer();
        });
    </script>
</body>
</html>